import{_ as a,c as i,o as e,ae as n}from"./chunks/framework.B2UkztZl.js";const l="/vitepress-study/assets/nuxt3_13_01.BSaKIECA.png",t="/vitepress-study/assets/nuxt3_13_02.RtGGAQub.gif",p="/vitepress-study/assets/nuxt3_13_03.Dc3xPRvj.gif",g=JSON.parse('{"title":"Nuxt3 學習筆記 - Ryan","description":"","frontmatter":{"title":"Nuxt3 學習筆記 - Ryan"},"headers":[],"relativePath":"pages/f2e/docVue/nuxt/nuxt3/nuxt3-13.md","filePath":"pages/f2e/docVue/nuxt/nuxt3/nuxt3-13.md"}'),r={name:"pages/f2e/docVue/nuxt/nuxt3/nuxt3-13.md"};function h(d,s,o,k,c,E){return e(),i("div",null,s[0]||(s[0]=[n('<h1 id="_13-中間件目錄-middleware-directory" tabindex="-1">13. 中間件目錄 (Middleware Directory) <a class="header-anchor" href="#_13-中間件目錄-middleware-directory" aria-label="Permalink to &quot;13. 中間件目錄 (Middleware Directory)&quot;">​</a></h1><p>在 <code>Vue</code> 的專案內我們的頁面通常由 <code>Vue Router</code> 來控制路由及導航，<code>Vue Router</code> 提供了 <code>導航守衛 (Navigation Guards)</code> 的 <code>Hook API</code>，讓我們可以在全域、路由甚至是元件中，來控制路由跳轉或取消的方式來守護我們的路由，不讓其隨意導航至特定頁面。<code>Nuxt 3</code> 提供了一個中間件的目錄，讓我們可以製作路由的中間件，來實作出類似導航守衛的效果。</p><h2 id="vue-router-的導航守衛-navigation-guards" tabindex="-1">Vue Router 的導航守衛 (Navigation Guards) <a class="header-anchor" href="#vue-router-的導航守衛-navigation-guards" aria-label="Permalink to &quot;Vue Router 的導航守衛 (Navigation Guards)&quot;">​</a></h2><p>導航守衛就是在訪問頁面之前，會攔截你的路由請求並執行自訂的驗證邏輯，依據驗證的成功與否，准予放行跳轉至路由頁面，抑或是取消訪問該路由，再依照不同處理方式進行中斷或重導向至特定路由頁面。</p><p>導航守衛在實務上常見的使用情境，就是拿來做頁面訪問的權限驗證，例如，只有管理員才能訪問 <code>/admin</code> 路由下的頁面，我們可能就會添加攔截的 <code>hook</code> 來驗證使用者是否登入及夾帶的 <code>Token</code> 或 <code>Role</code> 是否有權限可以瀏覽，如果驗證成功就准予瀏覽管理員相關頁面，否則，將路由頁面導回至首頁、登入頁或錯誤頁面，如同一個守衛在路由之間進行把關驗證權限。</p><p>我們以 <code>Vue Route v4</code> 來舉例，<code>Vue Route</code> 提供了以下三種情況下可以使用的 <code>hook</code>，分別是在 <code>全域</code>、<code>路由</code> 或是 <code>元件中</code>：</p><ul><li><h3 id="全域" tabindex="-1">全域 <a class="header-anchor" href="#全域" aria-label="Permalink to &quot;全域&quot;">​</a></h3><ul><li><h4 id="全域前置守衛-global-before-guards" tabindex="-1">全域前置守衛 (Global Before Guards) <a class="header-anchor" href="#全域前置守衛-global-before-guards" aria-label="Permalink to &quot;全域前置守衛 (Global Before Guards)&quot;">​</a></h4><p>當全域守衛 <code>hook</code> 添加好之後，每次導航至不同路由時，都會攔截以異步的方式執行相對應的處理邏輯。</p><p>全域守衛提供了 <code>router.beforeEach()</code> hook 可以在進入任何一個路由前進行攔截處理，當導航觸發時就會依照建立的順序做呼叫，因為是異步函數解析執行，所以在所有的守衛 <code>resolve</code> 之前，會一直處於 <code>pending</code> 的狀態。</p></li><li><h4 id="全域解析守衛-global-resolve-guards" tabindex="-1">全域解析守衛 (Global Resolve Guards) <a class="header-anchor" href="#全域解析守衛-global-resolve-guards" aria-label="Permalink to &quot;全域解析守衛 (Global Resolve Guards)&quot;">​</a></h4><p>而同樣是屬全域守衛的 <code>router.beforeResolve()</code> hook 會在所有元件內的導航守衛、路由都被解析及執行完畢後才執行，也就是說這個 <code>router.beforeResolve()</code> 呼叫的時間點晚於 <code>router.beforeEach()</code>。</p></li><li><h4 id="全域後置-hooks-global-after-hooks" tabindex="-1">全域後置 Hooks (Global After Hooks) <a class="header-anchor" href="#全域後置-hooks-global-after-hooks" aria-label="Permalink to &quot;全域後置 Hooks (Global After Hooks)&quot;">​</a></h4><p>與 <code>router.beforeEach()</code> hook 相反，全域後置 hooks 提供的 <code>router.afterEach()</code> Hook 會是在路由跳轉結束後才觸發，在這裡路由已經完成跳轉，路由本身也不會再被更動，這個 hook 通常用於分析類或設置頁面相關的資訊等輔助型的功能很有幫助。</p></li></ul></li><li><h3 id="路由獨有守衛-per-route-guard" tabindex="-1">路由獨有守衛 (Per-Route Guard) <a class="header-anchor" href="#路由獨有守衛-per-route-guard" aria-label="Permalink to &quot;路由獨有守衛 (Per-Route Guard)&quot;">​</a></h3><p>與 <code>router.beforeEach()</code> 不同，我們可以為每一個路由添加 <code>beforeEnter()</code> hook，來達到每一個路由頁面有不同的執行方法，同時也只會在不同的路由導航中切換才會觸發。</p></li><li><h3 id="元件內的守衛-in-component-guards" tabindex="-1">元件內的守衛 (In-Component Guards) <a class="header-anchor" href="#元件內的守衛-in-component-guards" aria-label="Permalink to &quot;元件內的守衛 (In-Component Guards)&quot;">​</a></h3><p>在元件的內部中，也提供三種 <code>hooks</code> 分別為：</p><ul><li><h4 id="beforerouteenter" tabindex="-1"><code>beforeRouteEnter()</code> <a class="header-anchor" href="#beforerouteenter" aria-label="Permalink to &quot;`beforeRouteEnter()`&quot;">​</a></h4><p>在路由進入並渲染這個元件之前呼叫，所以還沒有元件的實體可以操作使用。</p></li><li><h4 id="beforerouteupdate" tabindex="-1"><code>beforeRouteUpdate()</code> <a class="header-anchor" href="#beforerouteupdate" aria-label="Permalink to &quot;`beforeRouteUpdate()`&quot;">​</a></h4><p>目前的路由改變，而且還處於同一個元件中時呼叫。</p></li><li><h4 id="beforerouteleave" tabindex="-1"><code>beforeRouteLeave()</code> <a class="header-anchor" href="#beforerouteleave" aria-label="Permalink to &quot;`beforeRouteLeave()`&quot;">​</a></h4><p>當導航準備離開時且沒有使用到這個元件時呼叫。</p></li></ul><p><code>導航守衛 (Navigation Guards)</code> 在導航出發後的 hook 觸發順序如下圖：</p><p><img src="'+l+`" alt="nuxt3_13_01"></p></li></ul><h2 id="nuxt-3-路由中間件" tabindex="-1">Nuxt 3 路由中間件 <a class="header-anchor" href="#nuxt-3-路由中間件" aria-label="Permalink to &quot;Nuxt 3 路由中間件&quot;">​</a></h2><p><code>Nuxt 3</code> 中提供了一個路由中間件的框架，我們可以在專案下建立名為 <code>middleware</code> 目錄，在這個目錄下我們可以建立中間件，並讓整個 <code>Nuxt</code> 頁面或特定的路由做使用，也可以在頁面中添加，這個中間件可以理解為 <code>Vue Router</code> 中的 <code>導航守衛 (Navigation Guards)</code>，同樣有 <code>to</code> 與 <code>from</code> 參數用以在導航至特定路由之前驗證權限或執行商業邏輯等。</p><ul><li><h3 id="路由中間件格式" tabindex="-1">路由中間件格式 <a class="header-anchor" href="#路由中間件格式" aria-label="Permalink to &quot;路由中間件格式&quot;">​</a></h3><p>當我們想要建立路由中間件時，可以在 <code>Nuxt</code> 專案的 <code>middleware</code> 目錄下建立檔案，並預設匯出一個由 <code>defineNuxtRouteMiddleware()</code> 定義的函數，例如：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtRouteMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.params.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> abortNavigation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> navigateTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>路由中間件能接收目前的路由 <code>to</code> 與下一個路由 <code>from</code> 做為參數，如同 <code>Vue Router</code> 的導航守衛，以此我們就可以來做一些判斷與驗證操作。</p></li><li><h3 id="路由中間件的回傳" tabindex="-1">路由中間件的回傳 <a class="header-anchor" href="#路由中間件的回傳" aria-label="Permalink to &quot;路由中間件的回傳&quot;">​</a></h3><p><code>Nuxt</code> 提供了兩個全域的 <code>helpers</code>，可以直接從中間件回傳：</p><ul><li><h4 id="navigateto-to-options" tabindex="-1">navigateTo(to, options) <a class="header-anchor" href="#navigateto-to-options" aria-label="Permalink to &quot;navigateTo(to, options)&quot;">​</a></h4><p>在插件或中間件中重新定向到給定的路由。也可以直接呼叫它進行頁面導航。</p><p><code>navigateTo</code> 參數依序為：</p><ul><li><code>to</code>: <code>RouteLocationRaw | undefined | null</code></li><li><code>options</code>: <code>{ replace: boolean, redirectCode: number, external: boolean }</code></li></ul></li><li><h4 id="abortnavigation-err" tabindex="-1">abortNavigation(err) <a class="header-anchor" href="#abortnavigation-err" aria-label="Permalink to &quot;abortNavigation(err)&quot;">​</a></h4><p>可以在中間件中回傳 <code>abortNavigation()</code> 來中止導航，並可以選擇是否傳入錯誤訊息。</p><p><code>abortNavigation</code> 參數為：</p><ul><li><code>err?</code>: <code>string | Error</code></li></ul><p>與 <code>Vue Router</code> 中的導航守衛稍有不同，在 <code>Nuxt</code> 的中間件中可以使用 <code>navigateTo</code> 與 <code>abortNavigation</code> 來決定導航至新的路由或終止導航，如果中間件沒有回傳任何東西，則表示不阻塞導航，如果有下一個中間件，則而移往下一個功能做執行，或者完成路由導航。</p><p><code>nothing</code> - 不阻塞導航並且會移動到下一個中間件功能，如果有的話，或者完成路由導航 <code>return navigateTo(&#39;/&#39;)</code> 或 <code>return navigateTo({ path: &#39;/&#39; })</code> - 重定向到給定路徑，</p><p>如果使用 <code>navigateTo()</code> 重定向是發生在伺服器端，則將 <code>HTTP Status Code</code> 設置為 <code>暫時</code> 重定向狀態碼 <code>302 Found</code>。</p><p>如果使用 <code>navigateTo()</code> 並夾入 <code>options.redirectCode</code> 屬性，例如 <code>return navigateTo(&#39;/&#39;, { redirectCode: 301 })</code>，發生的重定向在伺服器端，將 <code>HTTP Status Code</code> 設置為 <code>永久</code> 重定向狀態碼 <code>301 Moved Permanently</code>。</p></li></ul></li><li><h3 id="路由中間件的種類" tabindex="-1">路由中間件的種類 <a class="header-anchor" href="#路由中間件的種類" aria-label="Permalink to &quot;路由中間件的種類&quot;">​</a></h3><p>在 <code>Nuxt</code> 中路由中間件分為以下三種：</p><ul><li><h4 id="匿名或者是行內的路由中間件" tabindex="-1">匿名或者是行內的路由中間件 <a class="header-anchor" href="#匿名或者是行內的路由中間件" aria-label="Permalink to &quot;匿名或者是行內的路由中間件&quot;">​</a></h4><p>不需要建立檔案，通常在路由頁面中使用 <code>definePageMeta()</code> 來定義的中間件，就屬於這種類型。</p><p>例如，直接定義一個匿名的中間件在頁面元件中使用：</p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> setup&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">definePageMeta({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  middleware: defineNuxtRouteMiddleware(() =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.log(\`[匿名中間件] 我是直接定義在頁面內的匿名中間件\`)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><h4 id="具名的路由中間件" tabindex="-1">具名的路由中間件 <a class="header-anchor" href="#具名的路由中間件" aria-label="Permalink to &quot;具名的路由中間件&quot;">​</a></h4><p>在 <code>middleware</code> 目錄下所建立的中間件，當在頁面使用 <code>definePageMeta()</code> 來指定使用具名的中間件時，將透過異步來自動載入。具名的路由的名稱被規範為是 <code>烤肉串式 (Kebab case)</code> 命名。</p><p>例如，建立一個 <code>./middleware/random-redirect.js</code> 中間件檔案：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtRouteMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`[來自 random-redirect 中間件] 重新導向至 /haha\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> navigateTo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/haha&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`[來自 random-redirect 中間件] 沒發生什麼特別的事情～\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>當我們要使用這個中間件時，可以在頁面中使用 <code>definePageMeta()</code> 並傳入 <code>middleware</code> 屬性，來添加路由中間件。</p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> setup&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">definePageMeta({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  middleware: &#39;random-redirect&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果中間件有多個，你也可以使用陣列來傳入多個中間件，並且會依序執行這些路由中間件。</p><div class="language-xml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> setup&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">definePageMeta({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  middleware: [&#39;random-redirect&#39;, &#39;other&#39;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>當我們在頁面中添加這個中間件後，在切換到這個路由頁面時，約有一半的機會，會被導航至 <code>/haha</code> 頁面。 <img src="`+t+'" alt="nuxt3_13_02"></p></li><li><h4 id="全域的路由中間件" tabindex="-1">全域的路由中間件 <a class="header-anchor" href="#全域的路由中間件" aria-label="Permalink to &quot;全域的路由中間件&quot;">​</a></h4><p>在具名的中間件的檔名添加後綴 <code>.global</code>，如 <code>auth.global.js</code>，這個路由中間件將會被自動載入，並在每次導航變更時自動執行。</p><p>例如，我們建立一個 <code>./middleware/always-run.global.js</code> 中間件檔案，內容如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtRouteMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`[全域中間件] to: ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}, from: ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">path</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>這個全域的路由中間件，將會在每一次導航切換頁面時執行。 <img src="'+p+`" alt="nuxt3_13_03"></p></li></ul></li><li><h3 id="動態添加路由中間件" tabindex="-1">動態添加路由中間件 <a class="header-anchor" href="#動態添加路由中間件" aria-label="Permalink to &quot;動態添加路由中間件&quot;">​</a></h3><p>你可以使用 <code>addRouteMiddleware()</code> 輔助函數來手動添加全域或命名路由中間件，例如在插件中。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineNuxtPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addRouteMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;global-test&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;這個是由插件添加的全域中間件，並將在每次路由變更時執行&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, { global: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addRouteMiddleware</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;named-test&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;這個是由插件添加的具名中間件，並將會覆蓋任何現有的同名中間件&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul><h2 id="小結" tabindex="-1">小結 <a class="header-anchor" href="#小結" aria-label="Permalink to &quot;小結&quot;">​</a></h2><p>在 <code>Nuxt</code> 中我們可以使用所提供的中間件框架，來建立路由頁面中的中間件，而路由中間件會在到特定路由之前執行想要運行的邏輯，對於驗證權限等非常方便，也正是實現 <code>導航守衛 (Navigation Guards)</code> 的方式。這篇我們主要講述的路由中間件，也將會與我們之後會提到的伺服器端的中間件有所不同，雖然名稱相似但與 <code>Nitro</code> 啟動時執行的伺服器中間件完全不同。</p>`,12)]))}const b=a(r,[["render",h]]);export{g as __pageData,b as default};
