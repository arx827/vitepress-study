import{_ as a,c as i,o as l,ae as s}from"./chunks/framework.B2UkztZl.js";const u=JSON.parse('{"title":"IT邦 - 讓 TypeScript 成為你全端開發的 ACE !","description":"","frontmatter":{"title":"IT邦 - 讓 TypeScript 成為你全端開發的 ACE !"},"headers":[],"relativePath":"pages/f2e/docTypeScript/it/partI/typeScript-1.md","filePath":"pages/f2e/docTypeScript/it/partI/typeScript-1.md"}'),t={name:"pages/f2e/docTypeScript/it/partI/typeScript-1.md"};function o(d,e,c,p,r,n){return l(),i("div",null,e[0]||(e[0]=[s('<h1 id="_01-typescript-的發展與概論" tabindex="-1">01 TypeScript 的發展與概論 <a class="header-anchor" href="#_01-typescript-的發展與概論" aria-label="Permalink to &quot;01 TypeScript 的發展與概論&quot;">​</a></h1><h2 id="_1-1-typescript-簡介" tabindex="-1">1.1 TypeScript 簡介 <a class="header-anchor" href="#_1-1-typescript-簡介" aria-label="Permalink to &quot;1.1 TypeScript 簡介&quot;">​</a></h2><p><code>TypeScript</code> 是建立在 <code>JavaScript</code> 的基礎上，除了擁有如其名的 <code>型別系統(TypeSystem)</code> 外，也擁有額外的語法。</p><h2 id="_1-2-typescript-可以解決什麼樣的問題" tabindex="-1">1.2 TypeScript 可以解決什麼樣的問題？ <a class="header-anchor" href="#_1-2-typescript-可以解決什麼樣的問題" aria-label="Permalink to &quot;1.2 TypeScript 可以解決什麼樣的問題？&quot;">​</a></h2><h3 id="_1-2-1-使用-javascript-開發時最常遇到的問題" tabindex="-1">1.2.1 使用 JavaScript 開發時最常遇到的問題 <a class="header-anchor" href="#_1-2-1-使用-javascript-開發時最常遇到的問題" aria-label="Permalink to &quot;1.2.1 使用 JavaScript 開發時最常遇到的問題&quot;">​</a></h3><ul><li><h4 id="使用-javascript-開發時最常遇到的問題與麻煩點" tabindex="-1">使用 JavaScript 開發時最常遇到的問題與麻煩點 <a class="header-anchor" href="#使用-javascript-開發時最常遇到的問題與麻煩點" aria-label="Permalink to &quot;使用 JavaScript 開發時最常遇到的問題與麻煩點&quot;">​</a></h4><ul><li><ol><li>除錯時，除非用眼力暴力掃瞄程式碼，否則 <code>免不了執行程式的步驟</code></li></ol></li><li><ol start="2"><li>沒有工具的輔助，單純寫程式，<code>錯字機率本來就很高</code></li></ol></li><li><ol start="3"><li>由於 <code>資料格式 / 型別 / 結構錯誤</code> 等，儘管程式執行過程沒錯誤，但 <code>出現非人類預期狀況</code></li></ol></li><li><ol start="4"><li><code>忘記要處理邊緣情境</code> 相關的問題</li></ol></li></ul></li></ul><h3 id="_1-2-2-動態語言-v-s-靜態語言" tabindex="-1">1.2.2 動態語言 V.S. 靜態語言 <a class="header-anchor" href="#_1-2-2-動態語言-v-s-靜態語言" aria-label="Permalink to &quot;1.2.2 動態語言 V.S. 靜態語言&quot;">​</a></h3><ul><li><h4 id="動態與靜態語言-dynamically-v-s-statically-typed-language" tabindex="-1">動態與靜態語言 Dynamically v.s. Statically Typed Language <a class="header-anchor" href="#動態與靜態語言-dynamically-v-s-statically-typed-language" aria-label="Permalink to &quot;動態與靜態語言 Dynamically v.s. Statically Typed Language&quot;">​</a></h4><ul><li><ol><li><code>動態</code> 語言的特色為：在 <code>程式運行</code> 的狀態下，也就是在英文文章裡會看到的 <code>Run-time</code> 期間，任何變數是經由被代入值來判斷其型別；也就是說，<code>變數的型別會依據存的值本身來判斷</code>。</li></ol></li><li><ol start="2"><li><code>靜態</code> 語言的特色則是：在 <code>程式正在編譯</code> 時，也就是所謂的 <code>Compilation</code> 期間，根據程式裡 <code>宣告的型別</code> (幾乎都適用 <code>文字</code> 來表示，如 <code>Int</code>、<code>Float</code> 等) 來監控型別的狀態。</li></ol></li></ul></li><li><h4 id="漸進式型別系統-gradual-typing" tabindex="-1">漸進式型別系統 Gradual Typing <a class="header-anchor" href="#漸進式型別系統-gradual-typing" aria-label="Permalink to &quot;漸進式型別系統 Gradual Typing&quot;">​</a></h4><p>兼具動態與靜態語言的特色 - 程式碼在編譯過程中可能會遇到變數或表達式(Expression) 被顯性地型別註記，這些變數會在靜態地編譯過程中檢測並且被監控；<code>某些沒有被註記型別的變數或表達式等，會在程式裡自行推斷 (Inference) 型別之結果</code>，如果遇到型別對應錯誤時釋放警告。</p></li><li><h4 id="型別註記-型別推論" tabindex="-1">型別註記 &amp; 型別推論 <a class="header-anchor" href="#型別註記-型別推論" aria-label="Permalink to &quot;型別註記 &amp; 型別推論&quot;">​</a></h4><ul><li><h5 id="型別註記-type-annotation" tabindex="-1"><code>型別註記 (Type Annotation)</code> <a class="header-anchor" href="#型別註記-type-annotation" aria-label="Permalink to &quot;`型別註記 (Type Annotation)`&quot;">​</a></h5> 為對變數或表達式進行 <code>文字敘述上的型別宣告動作</code>。</li><li><h5 id="型別推論-type-inference" tabindex="-1"><code>型別推論 (Type Inference)</code> <a class="header-anchor" href="#型別推論-type-inference" aria-label="Permalink to &quot;`型別推論 (Type Inference)`&quot;">​</a></h5> 則是 <code>變數根據被賦予的值之型別來代表該變數之型別</code>；而表達式則是 <code>經運算結果的值之型別來代表整個表達式最後的型別結果</code>。</li></ul><p>簡而言之，撇除掉已經被註記過後的東西，決定其他沒有被註記過後的東西之型別，就是看結果值的型別是什麼就對了。</p></li></ul><h3 id="_1-2-3-強型別語言-v-s-弱型別語言" tabindex="-1">1.2.3 強型別語言 V.S. 弱型別語言 <a class="header-anchor" href="#_1-2-3-強型別語言-v-s-弱型別語言" aria-label="Permalink to &quot;1.2.3 強型別語言 V.S. 弱型別語言&quot;">​</a></h3><ul><li><h4 id="強型別語言與弱型別語言-strongly-typed-v-s-weakly-typed-language" tabindex="-1">強型別語言與弱型別語言 Strongly Typed v.s. Weakly Typed Language <a class="header-anchor" href="#強型別語言與弱型別語言-strongly-typed-v-s-weakly-typed-language" aria-label="Permalink to &quot;強型別語言與弱型別語言 Strongly Typed v.s. Weakly Typed Language&quot;">​</a></h4><ul><li><code>弱型別語言</code> 對於任意型別的值之間的操作時，會 <code>自動轉換成適當的型別的值進行操作</code>。</li><li><code>強型別語言</code> 則相對不允許不符合預期的型別的值進行操作，例如在 Python 或 Ruby 裡隨意將非數字型別的值與另一個數值進行加減乘除。</li></ul></li><li><h4 id="typescript-語言本身的設計" tabindex="-1">TypeScript 語言本身的設計 <a class="header-anchor" href="#typescript-語言本身的設計" aria-label="Permalink to &quot;TypeScript 語言本身的設計&quot;">​</a></h4><p><code>TypeScript</code> 是一門擁有 <code>漸進式型別系統 (Gradual Typing)</code> 的 <code>弱型別語言 (Weakly Typed)</code></p></li></ul><h3 id="_1-2-4-typescript-改善、解決的開發相關的問題" tabindex="-1">1.2.4 TypeScript 改善、解決的開發相關的問題 <a class="header-anchor" href="#_1-2-4-typescript-改善、解決的開發相關的問題" aria-label="Permalink to &quot;1.2.4 TypeScript 改善、解決的開發相關的問題&quot;">​</a></h3><blockquote><p>使用型別註記功能時，靜態層面上監測變數或表達式之型別，所以在 <code>程式還未執行前</code>，可以抓到潛在的錯誤。</p></blockquote><blockquote><p>只要使用 <code>JavaScript Debug</code> 時，除非使用眼力掃整段程式碼來除 <code>Bug</code>，免不了 <code>必須執行程式碼</code> 並根據吐出之訊息來除 <code>Bug</code>。</p></blockquote><blockquote><p>有時候任何程式上的行為會出現各種結果 - 包含呼叫函式或方法、與陌生的第三者服務接觸等，可能會 <code>忘記要去處理這些邊緣情境 (Edge Cases)</code>。</p></blockquote><h2 id="_1-3-學習-typescript-的更多好處" tabindex="-1">1.3 學習 TypeScript 的更多好處 <a class="header-anchor" href="#_1-3-學習-typescript-的更多好處" aria-label="Permalink to &quot;1.3 學習 TypeScript 的更多好處&quot;">​</a></h2><h3 id="_1-3-1-對於各種不同版本-javascript-的編譯" tabindex="-1">1.3.1 對於各種不同版本 JavaScript 的編譯 <a class="header-anchor" href="#_1-3-1-對於各種不同版本-javascript-的編譯" aria-label="Permalink to &quot;1.3.1 對於各種不同版本 JavaScript 的編譯&quot;">​</a></h3><ul><li>開源社群提供的解決工具莫過於著名的 <code>Babel Compiler</code> - 負責將 <code>ECMAScript</code> 系列語法轉譯為 <code>ES5</code> 版本的語法。</li><li>也會需要自動化的環境來建造專案打包的流程。延伸出的打包專案的工具也是很多種類，像是幫助整合專案的 <code>Webpack</code> 以及進行排除未用程式碼功能的 <code>Rollup.JS</code> 等。</li><li>如果使用 <code>TypeScript</code> 的話，它的 <code>編譯器設定</code> 就會自動把程式碼編譯成 <code>JavaScript</code> 版本。</li></ul><h3 id="_1-3-2-typescript-擁有比較完善的物件導向語法" tabindex="-1">1.3.2 TypeScript 擁有比較完善的物件導向語法 <a class="header-anchor" href="#_1-3-2-typescript-擁有比較完善的物件導向語法" aria-label="Permalink to &quot;1.3.2 TypeScript 擁有比較完善的物件導向語法&quot;">​</a></h3><p><code>TypeScript</code> 的主要語言設計者 <code>Anders</code> 也是 <code>C#</code> 語言的設計者，因此在型別系統以及物件導向方面的語法也有跟 <code>C#</code> 這門語言有相似之處。</p><h3 id="_1-3-3-typescript-定義檔具備使用說明文件的性質" tabindex="-1">1.3.3 TypeScript 定義檔具備使用說明文件的性質 <a class="header-anchor" href="#_1-3-3-typescript-定義檔具備使用說明文件的性質" aria-label="Permalink to &quot;1.3.3 TypeScript 定義檔具備使用說明文件的性質&quot;">​</a></h3><p>除了上網查官方網站版本的文件外，也可以查詢名為 <code>TypeScript 定義檔 (Definition File)</code> 的東西。</p><h2 id="_1-4-征途路上總是也有跌跌撞撞的時候" tabindex="-1">1.4 征途路上總是也有跌跌撞撞的時候 <a class="header-anchor" href="#_1-4-征途路上總是也有跌跌撞撞的時候" aria-label="Permalink to &quot;1.4 征途路上總是也有跌跌撞撞的時候&quot;">​</a></h2><h3 id="_1-4-1-命名是門哲學-踏入-typescript-更是如此" tabindex="-1">1.4.1 命名是門哲學，踏入 TypeScript 更是如此 <a class="header-anchor" href="#_1-4-1-命名是門哲學-踏入-typescript-更是如此" aria-label="Permalink to &quot;1.4.1 命名是門哲學，踏入 TypeScript 更是如此&quot;">​</a></h3><h3 id="_1-4-2-型別與介面-你們搞得我好亂啊" tabindex="-1">1.4.2 型別與介面，你們搞得我好亂啊！ <a class="header-anchor" href="#_1-4-2-型別與介面-你們搞得我好亂啊" aria-label="Permalink to &quot;1.4.2 型別與介面，你們搞得我好亂啊！&quot;">​</a></h3><p>在學習跟物件導向方面的概念以及實踐一些設計模式時，會比較清楚型別與介面各自使用的時機。</p><h3 id="_1-4-3-引入第三方套件" tabindex="-1">1.4.3 引入第三方套件 <a class="header-anchor" href="#_1-4-3-引入第三方套件" aria-label="Permalink to &quot;1.4.3 引入第三方套件&quot;">​</a></h3><p>這個所謂使用 <code>TypeScript</code> 開發時的陣痛的概念遠比使用原生 <code>JavaScript</code> 還來得大很多。</p><h3 id="_1-4-4-命名空間與模組-避不了的學習門檻" tabindex="-1">1.4.4 命名空間與模組，避不了的學習門檻 <a class="header-anchor" href="#_1-4-4-命名空間與模組-避不了的學習門檻" aria-label="Permalink to &quot;1.4.4 命名空間與模組，避不了的學習門檻&quot;">​</a></h3><p><code>TypeScript</code> 比起 <code>ES6</code> 的標準還要來個早三年多；也就是說 <code>TypeScript</code> 在 <code>import/export</code> 語法釋出前就有一套名為 <code>命名空間 (Namespaces)</code> 與 <code>模組 (Module)</code> 相關的語法。</p><h2 id="_1-5-旅程中的第一小步" tabindex="-1">1.5 旅程中的第一小步 <a class="header-anchor" href="#_1-5-旅程中的第一小步" aria-label="Permalink to &quot;1.5 旅程中的第一小步&quot;">​</a></h2><h3 id="_1-5-1-環境建構" tabindex="-1">1.5.1 環境建構 <a class="header-anchor" href="#_1-5-1-環境建構" aria-label="Permalink to &quot;1.5.1 環境建構&quot;">​</a></h3><ul><li><p>確保電腦有 <code>NodeJS</code> 的環境</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">which</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>此指令結果，會顯示 <code>Node</code> 被下載的位置。</p><blockquote><p>若出現 <code>node not found</code>，則代表你的主機沒有 <code>NodeJS</code>，請上 <a href="https://nodejs.org/zh-tw" target="_blank" rel="noreferrer">Node 官網</a> 下載。</p></blockquote></li><li><p>當 <code>NodeJS</code> 下載完成時，會附帶一個名為 <code>npm</code> 的指令 - 是 <code>NodeJS</code> 圈的模組管理工具。</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">which</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> npm</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>可以開始下載 <code>TypeScript</code> 的編譯指令工具囉</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> typescript</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>下載完成後，檢測</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">which</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tsc</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul><h3 id="_1-5-2-編輯器以及設定-建議使用-vscode" tabindex="-1">1.5.2 編輯器以及設定 - 建議使用 VSCode <a class="header-anchor" href="#_1-5-2-編輯器以及設定-建議使用-vscode" aria-label="Permalink to &quot;1.5.2 編輯器以及設定 - 建議使用 VSCode&quot;">​</a></h3><h3 id="_1-5-3-從第一個-hello-world-程式-學習正確地使用-vscode" tabindex="-1">1.5.3 從第一個 Hello World 程式，學習正確地使用 VSCode <a class="header-anchor" href="#_1-5-3-從第一個-hello-world-程式-學習正確地使用-vscode" aria-label="Permalink to &quot;1.5.3 從第一個 Hello World 程式，學習正確地使用 VSCode&quot;">​</a></h3><ul><li><p>新增檔案 <code>hello-world.ts</code></p></li><li><p>打開檔案，並開始撰寫程式碼</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(message);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello world!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li><li><p>開啟終端機，並且進到 <code>hello-world.ts</code> 所在的資料夾，並下達指令</p><div class="language-sh vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tsc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello-world.ts</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>編譯結果沒問題時，<code>tsc</code> 就會產生名為 <code>hello-world.js</code> 檔案</p></li><li><h4 id="vscode-提供的功能與使用技巧" tabindex="-1">VSCode 提供的功能與使用技巧 <a class="header-anchor" href="#vscode-提供的功能與使用技巧" aria-label="Permalink to &quot;VSCode 提供的功能與使用技巧&quot;">​</a></h4><ul><li><ol><li><code>自動補全功能 (Autocomplete)</code>：宣告過後的變數、函式等都可以很快速的被自動補全。</li></ol></li><li><ol start="2"><li><code>型別提示 (Type Hint)</code>：將滑鼠移動到變數、函式等，會跳出型別方面的內容提示。</li></ol></li><li><ol start="3"><li><code>型別衝突偵測</code>：使用 <code>TypeScript</code> 開發的過程中，如果偵測到型別上的衝突，<code>VSCode</code> 就會主動跳出警訊，提醒開發者要注意有潛在的錯誤發生 - 這也是使用 <code>TypeScript</code> 開發時，不太需要主動執行程式就可以快速除蟲的重點功能之一。</li></ol></li><li><ol start="4"><li><code>快速查詢</code>：如果想要快速查詢某變數、函式、型別宣告或定義所在的內容與位置，可以將鼠標移動到想要查詢的目標上，按下 <code>Ctrl (MacOS 上則是按下command ⌘)</code> 的同時，並按下滑鼠，此時就可以快速導向到該目標上。</li></ol></li></ul></li></ul>',35)]))}const y=a(t,[["render",o]]);export{u as __pageData,y as default};
