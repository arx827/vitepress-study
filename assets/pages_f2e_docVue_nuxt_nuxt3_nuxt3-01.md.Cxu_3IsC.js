import{_ as t,c as a,o as d,ae as i}from"./chunks/framework.B2UkztZl.js";const l="/vitepress-study/assets/nuxt3_01_01.DRoIQ2kk.png",o="/vitepress-study/assets/nuxt3_01_02.wv0py2VJ.png",_=JSON.parse('{"title":"Nuxt3 學習筆記","description":"","frontmatter":{"title":"Nuxt3 學習筆記"},"headers":[],"relativePath":"pages/f2e/docVue/nuxt/nuxt3/nuxt3-01.md","filePath":"pages/f2e/docVue/nuxt/nuxt3/nuxt3-01.md"}'),r={name:"pages/f2e/docVue/nuxt/nuxt3/nuxt3-01.md"};function c(n,e,s,u,h,S){return d(),a("div",null,e[0]||(e[0]=[i('<h1 id="_1-淺談-csr、ssr-與-ssg" tabindex="-1">1. 淺談 CSR、SSR 與 SSG <a class="header-anchor" href="#_1-淺談-csr、ssr-與-ssg" aria-label="Permalink to &quot;1. 淺談 CSR、SSR 與 SSG&quot;">​</a></h1><h2 id="csr-客戶端渲染-前端渲染-client-side-rendering" tabindex="-1">CSR 客戶端渲染/前端渲染 (Client-Side Rendering) <a class="header-anchor" href="#csr-客戶端渲染-前端渲染-client-side-rendering" aria-label="Permalink to &quot;CSR 客戶端渲染/前端渲染 (Client-Side Rendering)&quot;">​</a></h2><ul><li>由 <code>Vue</code>、<code>React</code> 等前端框架常用。</li><li>瀏覽器接收到幾乎空白的 <code>HTML</code>，其中只包含一個「<code>容器</code>」。</li><li>之後再藉由 <code>JavaScript</code> 在終端 <code>使用者端（client）</code> 渲染出完整內容。</li><li>適合畫面互動性高的 <code>SPA</code>，但 <code>SEO</code> 效果差、初次載入時間較長。</li></ul><p><img src="'+l+'" alt="nuxt3_01_01"></p><ul><li><h3 id="優點" tabindex="-1">優點 <a class="header-anchor" href="#優點" aria-label="Permalink to &quot;優點&quot;">​</a></h3><ul><li>跳轉頁面時，不再需要由伺服器重新渲染整個頁面，前端框架會幫我們實現部分元素更新，使用者體驗較佳。</li><li>實現前後端分離，讓前端能更專注 UI 開發，後端專注 API。</li><li>因為渲染工作皆在客戶端完成，伺服器負擔也較小。</li></ul></li><li><h3 id="缺點" tabindex="-1">缺點 <a class="header-anchor" href="#缺點" aria-label="Permalink to &quot;缺點&quot;">​</a></h3><ul><li>首次進入網站時，可能需要較長的下載 JS 與載入渲染時間會有白畫面問題。</li><li>不利於 <code>SEO</code>，搜尋引擎爬蟲蒐集資料時多數不執行 JS 或頁面過於複雜，而導致無法獲得初始頁面資料；搜尋引擎對於 CSR 雖有解決方案，但是仍不夠友善。</li></ul></li></ul><h2 id="ssr-伺服器端渲染-server‐side-rendering" tabindex="-1">SSR 伺服器端渲染 (Server‑Side Rendering) <a class="header-anchor" href="#ssr-伺服器端渲染-server‐side-rendering" aria-label="Permalink to &quot;SSR 伺服器端渲染 (Server‑Side Rendering)&quot;">​</a></h2><ul><li>每次請求時，伺服器回傳已經填滿資料的完整 HTML 給瀏覽器。</li><li>適合頁面內容頻繁更新的網站（如新聞、動態資料）。</li><li><code>SEO</code> 效果佳，但伺服器負載大，回應時間可能變長。</li></ul><p><img src="'+o+'" alt="nuxt3_01_02"></p><ul><li><h3 id="優點-1" tabindex="-1">優點 <a class="header-anchor" href="#優點-1" aria-label="Permalink to &quot;優點&quot;">​</a></h3><ul><li>有利於 <code>SEO</code>，首次進入網站時，網頁 <code>HTML</code> 就已經在伺服器端渲染生成完畢，搜尋引擎爬蟲便能準確抓取最終網頁資料。</li></ul></li><li><h3 id="缺點-1" tabindex="-1">缺點 <a class="header-anchor" href="#缺點-1" aria-label="Permalink to &quot;缺點&quot;">​</a></h3><ul><li>跳轉頁面時，網頁都需要再重新載入，導致用戶體驗較差。</li><li>因為渲染工作皆在伺服端完成，所以每次都需要重新取得整個頁面的 <code>API</code> 的資料與渲染，對於伺服器負擔也較大。</li></ul></li></ul><h2 id="ssg-靜態網頁生成-static-site-generation" tabindex="-1">SSG 靜態網頁生成 (Static Site Generation) <a class="header-anchor" href="#ssg-靜態網頁生成-static-site-generation" aria-label="Permalink to &quot;SSG 靜態網頁生成 (Static Site Generation)&quot;">​</a></h2><ul><li><p>在網站 <code>build</code> 階段預先生成好完整的 <code>HTML</code> 檔案。</p></li><li><p>每次請求都直接回傳相同 <code>HTML</code>，速度快、伺服器負載低。</p></li><li><p>適合資料不常變動的頁面，不適合高頻更新內容。</p></li><li><h3 id="優點-2" tabindex="-1">優點 <a class="header-anchor" href="#優點-2" aria-label="Permalink to &quot;優點&quot;">​</a></h3><ul><li>打包編譯時產生出網頁原始碼 <code>HTML</code> 檔案，即靜態資源檔案，因此能很好的搭 <code>CDN</code> 緩存來減輕伺服器負擔。</li><li>有利於 <code>SEO</code>，因為打包編譯時產生出網頁原始碼 <code>HTML</code> 檔案，正是可以讓搜尋引擎爬蟲解析的完整網頁資料。</li></ul></li><li><h3 id="缺點-2" tabindex="-1">缺點 <a class="header-anchor" href="#缺點-2" aria-label="Permalink to &quot;缺點&quot;">​</a></h3><ul><li>如果頁面經常變動，就得再一次打包編譯，重新產生出新的一份網頁原始碼 <code>HTML</code> 檔案。</li></ul></li></ul><h2 id="各渲染方式比較" tabindex="-1">各渲染方式比較 <a class="header-anchor" href="#各渲染方式比較" aria-label="Permalink to &quot;各渲染方式比較&quot;">​</a></h2><table tabindex="0"><thead><tr><th>渲染方式</th><th>HTML產出時機</th><th>特性</th><th>適用場景</th></tr></thead><tbody><tr><td><code>CSR</code></td><td>Client 端載入時動態生成</td><td>SEO 差、初次載入慢、互動性強</td><td>單頁應用（SPA）</td></tr><tr><td><code>SSR</code></td><td>每次請求時由伺服器生成</td><td>SEO 好、動態性佳，但伺服器負載高</td><td>新聞類、動態資料頁面</td></tr><tr><td><code>SSG</code></td><td>Build 時預先生成</td><td>快速、低負荷，但無動態能力</td><td>Blog、產品展示、Landing Page 等</td></tr></tbody></table><h2 id="ssr-後端渲染-spa-單頁式應用程式" tabindex="-1">SSR (後端渲染) + SPA (單頁式應用程式) <a class="header-anchor" href="#ssr-後端渲染-spa-單頁式應用程式" aria-label="Permalink to &quot;SSR (後端渲染) + SPA (單頁式應用程式)&quot;">​</a></h2><p>若是採用 <code>SSR</code> 渲染首次進入的 <code>HTML</code>，再用 <code>CSR</code> 做後續動態的取資料更新畫面，不就能解決 <code>SPA</code> 常見的白畫面或 <code>SEO</code> 優化問題嗎？</p><p>=&gt; <code>Nuxt</code> 框架 或 <code>Next.js</code></p>',16)]))}const x=t(r,[["render",c]]);export{_ as __pageData,x as default};
